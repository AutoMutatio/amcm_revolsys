/*
 * Copyright 2004-2005 Revolution Systems Inc.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.revolsys.xml.io;

import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

import javax.xml.namespace.QName;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamReader;

/**
 * <p>
 * The XmlProcessor class provides a framework for processing an XML Document to
 * create a Java Object representation of the document or to perform other
 * actions on the contents of the document. The XmlProcessor uses the STAX API
 * to read the XML document using the {@link XMLStreamReader}, by using the
 * streaming API the XML parser will not load the XML document into memory
 * (although the Java Object representation created by subclasses of
 * XmlProcessor would likely be in memory at all times).
 * </p>
 * <p>
 * Users of a XmlProcessor implementation construct a new instance of the
 * subclass and invoke the {@link #process(XMLStreamReader)} method to process
 * the document and return the result object generated by the processor.
 * </p>
 * <p>
 * To process a document using the XmlProcessor a subclass of XmlProcessor must
 * be created for each XML namespace that needs to be processed. For each XML
 * element defined for the XML namespace a process method must be defined in the
 * subclass. The name of the process method must have the "process" prefix
 * followed bfollowed by the XML element name, have only an
 * {@link XMLStreamReader} parameter and return an Object (any subclass of
 * Object can be returned).
 * </p>
 * <p>
 * For example the process method for the XML element BankAccount would have the
 * following signature.
 * </p>
 * 
 * <pre>
 * public BankAccount processBankAccount(
 *   XMLStreamReader parser);
 * </pre>
 * <p>
 * For example the process method for the XML element firstName would have the
 * following signature. <b>Note that the part of the method name for the XML
 * element must have the same case as the XML element name.
 * </p>
 * 
 * <pre>
 * public String processfirstName(
 *   XMLStreamReader parser);
 * </pre>
 * <p>
 * The process methods read the attributes from the element and can either
 * create an Object for the XML element or perform other processing on the
 * element. This object can be returned from the process method so that the
 * calling method can access the object. If an XML element has child elements it
 * can either ignore them using the
 * {@link StaxUtils#skipSubTree(XMLStreamReader)} method or process the child
 * element using the {@link #process(XMLStreamReader)} method that will invoke
 * the appropriate process method for that element.
 * </p>
 * <p>
 * The following example shows the implementation of a process method for a
 * Person element that has a firstName and lastName element. As no children are
 * expected the {@link StaxUtils#skipSubTree(XMLStreamReader)} method is used to
 * skip to the end of the element.
 * </p>
 * 
 * <pre>
 * public Person processPerson(
 *   final XMLStreamReader parser)
 *   throws XMLStreamException,
 *   IOException {
 *   String firstName = parser.getAttributeValue(null, &quot;firstName&quot;);
 *   String lastName = parser.getAttributeValue(null, &quot;lastName&quot;);
 *   Person person = new Person(firstName, lastName);
 *   StaxUtils.skipSubTree(parser);
 *   return person;
 * }
 * </pre>
 * <p>
 * The following example shows the implementation of a process method for a
 * Family element that has one or more Person or Pet child elements. If an
 * unexpected element occurs and error will be recorded.
 * </p>
 * 
 * <pre>
 * public Family processFamily(
 *   final XMLStreamReader parser)
 *   throws XMLStreamException,
 *   IOException {
 *   Family family = new Family();
 *   while (parser.nextTag() == XMLStreamReader.START_ELEMENT) {
 *     Object object = process(parser);
 *     if (object instanceof Person) {
 *       config.addPerson((Person)object);
 *     } else if (object instanceof Pet) {
 *       config.addPet((Pet)object);
 *     } else {
 *       context.addError(&quot;Unexpected Element:&quot; + object, null,
 *         parser.getLocation());
 *     }
 *   }
 *   return family;
 * }
 * </pre>
 * 
 * @author Paul Austin
 */
public abstract class XmlProcessor {
  /** The arguments a processor method must have. */
  private static final Class[] PROCESS_METHOD_ARGS = new Class[] {
    XMLStreamReader.class
  };

  /** The cache of processor classes to method caches. */
  private static final Map processorMethodCache = new HashMap();

  /**
   * Create the cache of process methods from the specified class.
   * 
   * @param processorClass The XmlPorcessor class.
   * @return The map of method names to process methods.
   */
  private static Map getMethodCache(
    final Class processorClass) {
    Map methodCache = (Map)processorMethodCache.get(processorClass);
    if (methodCache == null) {
      methodCache = new HashMap();
      processorMethodCache.put(processorClass, methodCache);
      final Method[] methods = processorClass.getMethods();
      for (int i = 0; i < methods.length; i++) {
        final Method method = methods[i];
        final String methodName = method.getName();
        if (methodName.startsWith("process")) {
          if (Arrays.equals(method.getParameterTypes(), PROCESS_METHOD_ARGS)) {
            methodCache.put(methodName.substring(7), method);
          }
        }
      }
    }
    return methodCache;
  }

  /** The context for processing of the XML Document. */
  private XmlProcessorContext context = new SimpleXmlProcessorContext();

  /** The cache of XML element names to processor methods. */
  private final Map methodCache;

  /** The XML namespace URI processed by this processor. */
  private final String namespaceUri;

  /**
   * Construct a new XmlProcessor for the XML Namespace URI.
   * 
   * @param namespaceUri The XML Namespace URI.
   */
  protected XmlProcessor(
    final String namespaceUri) {
    this.namespaceUri = namespaceUri;
    methodCache = getMethodCache(getClass());
  }

  /**
   * Get the context for processing the XML Document.
   * 
   * @return The context for processing the XML Document.
   */
  public final XmlProcessorContext getContext() {
    return context;
  }

  /**
   * Get the method to process the XML element.
   * 
   * @param element The element to process.
   * @return The method to process the XML element.
   */
  private Method getProcessMethod(
    final QName element) {
    final String elementName = element.getLocalPart();
    final Method method = (Method)methodCache.get(elementName);
    if (method == null) {
      throw new IllegalArgumentException("No process method found for "
        + elementName);
    }
    return method;
  }

  /**
   * <p>
   * The process method is used to return an object representation of the
   * current XML element and subtree from the {@link XMLStreamReader}. The
   * method finds the process method in the subclass that has the method name
   * with the prefix "process" followed by the XML element name, have only an
   * {@link XMLStreamReader} parameter and return an Object (any subclass of
   * Object can be returned).
   * </p>
   * <p>
   * For example the process method for the XML element BankAccount would have
   * the following signature.
   * </p>
   * 
   * <pre>
   * public BankAccount processBankAccount(
   *   XMLStreamReader parser);
   * </pre>
   * <p>
   * For example the process method for the XML element firstName would have the
   * following signature. <b>Note that the part of the method name for the XML
   * element must have the same case as the XML element name.
   * </p>
   * 
   * <pre>
   * public String processfirstName(
   *   XMLStreamReader parser);
   * </pre>
   * 
   * @param parser The STAX XML parser.
   * @return The object representation of the XML subtree.
   * @throws IOException If an I/O exception occurs.
   * @throws XMLStreamException If an exception processing the XML occurs.
   */
  public Object process(
    final XMLStreamReader parser)
    throws XMLStreamException,
    IOException {
    final QName element = parser.getName();
    try {
      final Method method = getProcessMethod(element);
      return method.invoke(this, new Object[] {
        parser
      });
    } catch (final IllegalAccessException e) {
      throw new RuntimeException(e);
    } catch (final InvocationTargetException e) {
      final Throwable t = e.getTargetException();
      if (t instanceof RuntimeException) {
        throw (RuntimeException)t;
      } else if (t instanceof Error) {
        throw (Error)t;
      } else if (t instanceof XMLStreamException) {
        throw (XMLStreamException)t;
      } else if (t instanceof IOException) {
        throw (IOException)t;
      } else {
        throw new RuntimeException(t.getMessage(), t);
      }
    } catch (final IllegalArgumentException e) {
      StaxUtils.skipSubTree(parser);
    }
    return null;
  }

  /**
   * Set the context for processing the XML Document.
   * 
   * @param context The context for processing the XML Document.
   */
  public final void setContext(
    final XmlProcessorContext context) {
    this.context = context;
  }
}
